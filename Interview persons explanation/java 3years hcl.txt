(341) HCL 3 Years Interview Experience | Java Springboot | Selected - YouTube
https://www.youtube.com/watch?v=bERLe8g0Zvw

Transcript:
(00:00) uh could you please uh tell me about yourself in brief uh okay so uh for the last years uh I have worked as a Java developer uh mainly working on building pack and system by using Technologies like spring boot Spring Security and rest API ET Etc uh I have completed my graduation in computer science and engineering and uh since then uh I have worked on several complex projects uh like e-commerce clone Telecom applications etc etc I took the lead in some of these projects and successfully delivered important feature to our clients and uh this work
(00:38) has helped me grow my skills and uh basically I learned uh how to lead and communicate with clients by working on these projects okay so uh can you tell me about your recent projects okay so uh recently I worked on making an application for a retail business uh to keep track of their items uh so basically I use Java and spring boot for the back end and angular for making the front end uh the main job of this application is to help the shop know how much stuff they have uh handle orders and update item counts automatically uh we use spring boot to
(01:19) manage all the heavy duty task like uh talking to the database and making sure the different parts of the system can te can talk to each other easily right uh for saving all the basically we chose myql because it's a it's good at handling lots of information quickly and uh putting spring Boot and react together was a bit tricky at first uh especially getting them to share information without any issues so basically uh that project helped me get better at building complete applications uh that can do a
(01:52) lot of things and are easier for people to use so yeah it was a great way to learn about using both spring boot for the back end and uh react uh for the front end so uh we just built I mean we were working on this project as a team so I my primary uh task was to work on a back end only okay so uh what did you use for handling concurent user in this project okay so I handled many users at the same time uh for this project uh through the Springport by using two main ideas uh thread pools uh and doing thing asynchronously okay so thread pools
(02:37) helps me Li at how many things can run at once so the server doesn't get overwhelmed and doing things asynchronously means that the server can move onto the other task while waiting for something to finish okay instead of just waiting around so this way the server can deal with more users without getting slowed down so that's how uh I implemented I mean I handled the concurrent users okay so uh can you please tell me the annotations of a synchronous functionality okay sotion for as synchronous functionality
(03:14) okay so for as synchronous functionality in a spring boot uh basically uh I use a sync annotation and uh this tells the spring boot to run the anotated method in a separate thre and allowing the main process so continue without waiting for the method to complete so yeah yeah that's okay how can you synchronize two Java process okay so basically uh to make two Java processes work together smoothly uh we can use things like sockets okay which let them send messages to each other over a network or a shared database where both processes can read
(03:54) and write information to coordinate right and uh another way is through a shared file system uh where the process can create read and write files to communicate etc etc and you can also use logs to make sure they don't interfere with each other right so yeah I think these techniques help the processes to stange sync and uh uh and cooperate with each other so yeah okay so uh moving to the next question uh describe the key component of java virtual machine architecture okay so basically it has three parts right the class loader the runtime data
(04:36) areas and the execution engine okay so the class loader loads class files into the jvm right and the runtime data areas store data needed while the program runs uh like memory for variables and code and the last part the execution engine actually runs the instruction in the class files together so these components lets us run Java program on any device that has a jvf and these things basically make Java right ones and run anywhere okay so uh can you tell me how the Heap and stack memory areas differ okay so in the jbm uh the Heap
(05:19) and St memory uh serves the different purposes right uh the Heap is like a big storage room for all the objects created by Java application okay uh it's where the memory for all class instances and arrays allocated uh this area is managed by the garbage character uh which cleans up unused object uh to the free memory okay and uh on the other hand the stack is uh like a notebook stack for method calls okay uh that stores local variables and function call details and each threads in Java application has its
(05:57) own stack and making it thread whereas the Heap is shared across uh threads while the Heap is for sorry whereas the Heap is shared across sets and it's for used for dynamic memory location of the object and the St is for static memory location uh just tied up to the execution of methods okay so uh how does the Java enhance the performance of execution engine okay so basically Java uh makes uh faster it's engine by using uh git just in time compilation okay uh instead of slowing down throw bite code one line at a time
(06:48) git turns bite code into the N native machine code right before it's needed okay so this means that once a piece of code is compiled it can run quickly every time after that uh just like programs made for a specific type of computer okay also uh Java us is smart ways to make code run faster like uh removing parts that are not needed and making repeated task run more efficiently uh okay and this helps Java program run faster almost as fast as if they were designed specific specifically uh for the computers they are running on
(07:25) yeah so yeah that's I currently I know these two methods I mean Java enhance performance yeah okay so uh can you tell me how does the Java Implement polymorphism so basically Java uses two main ways to achieve polymorphism uh which is the ability for the same code to act differently based on what type of objects it's dealing with okay first if a class overrides a method that comes from a parent class so Java decides which versions of the method to use uh based based on the actual object type not on what the code
(08:02) says the object is okay uh and this lets the same piece of code work differently uh with different objects and the second Java uses interfaces okay uh which are like promises that a class will include certain methods and uh yeah this way a single class can follow different set of interfaces and acting in a various way depending on which interfaces is referred to so yeah these are the two ways okay so uh can changing exis modifier affect polymorphic behavior in overridden method uh yes so yes changing exess modifier can impact how overridden
(08:45) methods Works in Java so basically if you override a method uh we can't make it more private than it was in the present class okay for example uh if a method in the parent class is public so we cannot make the overridden method in the the child class protected or private okay doing this wrong can stop the method from being overwritten correctly and it will just mess up the ability to use polymorphism so polymorphism let us use the same method in different ways but if the exis levels are not set correctly okay so it can cause errors
(09:18) and prevented the program from running as expected okay so uh how does the super keyword play a role in polymorphism especially in the context of method over uh okay so the super keyword in Java helps with polymorphism during method overwriting uh by letting a subass call a method from its parent class okay so when a subass overwrites a method but it still want to use the version in the parent class so it can use super to do so okay and this is useful for adding to the behavior of the inherited method not just uh replacing
(09:58) it okay okay so yeah so super allows both the original and the new method to work together and enhancing the way a program can use different versions of the same method okay so uh can you explain how Java handle access visibility in sub classes okay so yeah I can tell you so basically in Java when one class inherits from another how it can see or use the parents class stuff depends on access level so there are three or there are four access level a public protective and uh uh no no specific keyword and private I mean default and
(10:40) private okay anything marked public can be seen anywhere uh whereas proted things are seen in sub classes or in the same package okay and uh the default one I mean where we don't use any uh keyword so this means only classes in the same package can see it and subass outside the package can cannot and the private things cannot be seen by subass at all uh so when a subass overrides a method uh so it can make it more open uh but not more restricted so yeah this setup helps keep things organized and definitely secure in Java
(11:18) programs okay so uh moving to the next question uh how does polymorphism benefits a Java collection framework okay so polymorphism helps the Java collection framework by uh letting it treat different types of collections the same way okay for example whether we are using an array list or link list we can work with both using the list interfaces okay this means uh we can switch from one type to another without changing much of our code okay so it makes our code more flexible and easier to manage uh manage and plus it allows
(11:56) the collections to use a common set of methods and make making it simpler to work with and understand so yeah that's how can use polymorphism I mean you can take benefit of polymeris okay so uh in collection how does the hash set ensure that there is are not duplicates okay so basically a headset in Java makes sure that there are no duplicates by using uh something called a hash table okay so when we try to add a new item HH set calculates a space special code for it and this is special code is nothing but a hash code okay so
(12:34) this code decides where in the hash table the item should go okay if there's already an item with the same code in that spot so the new item won't be added because it's considered a duplicate so yeah this way headset quickly keeps only unique items without having to look through each item one by one okay so uh can you describe how hash code and equals work together in the collection uh yeah sure so basically in Java Collections hash code and equal methods work together to identify unique objects okay so when an object is added to the
(13:09) collection hash basically calculates a sorry hash method basically calculates a hash code or that determines where the object should be placed right and if two objects have the same HH code uh then equal method is used to check if they are truly equal uh if equal methods returns true then the objects are considered duplicate and this com combination will tell that each object in a collection like a HH set is unique by its data not just by its memory address and uh and allowing efficient storage and retrieval of
(13:44) objects okay so uh can you uh explain how does Java it stream API enhance collection process uh okay so yeah sure so Java stream API makes working with collections much easier uh much easier and more efficient so what it do is it lets us perform perform operations like filtering soing and uh sorry fil filtering and sort sorting and converting items in a collection with just a few lines of code and it also supports doing task in parallel which means now it can process large amounts of data Foster by using multiple process
(14:22) scores so yeah this makes our code not only shorter and cleaner but also faster and more powerful especially for big collections okay so uh what are the issue of using a mutable object as a key in a hashmap Yeah so basically by using a mutable object as a key in a hmap uh can lead a lot of issues right if the object State changes after it's placed into the H map so it hedge code May changes as well right and this means the hmap might not find the object later because uh it's looking in the wrong place based on
(14:58) the original hash code okay so yeah as a result then we can loss access to that entry and uh making it Behavior unpredictable right and so so that's why it's recommended to use aable objects as key to ensure consistent Behavior as their hash qus remains constant and ensuring the Integrity of the hashmap structure and the uh entries so yeah gu so can you describe a complex problem you solve using a Java collection okay so I solved problem where I needed to find all unique pairs of numbers in a list that add up to a
(15:41) certain number okay so in that case uh I use a hashmap to quickly check if I already had seen the number needed to complete a pair okay for example uh let's say if my target sum was 10 okay and I had a three then I checked if I had a seven already and if I did I added the pair 37 to an array list because it's a match right and this way by combining headset for the fast searches and arist to keep track of the pairs I efficiently found all unique pairs that added to the Target some so that was one of the problem and my project dat I
(16:20) solved by using uh the Java collection okay so uh can we create a server in Java application with without using a spring framework uh yes uh uh we can create a server in Java uh without using the spring framework so basically in Java uh has built in tools like the server socket class that let us listen for and handle Network request okay and by writing code that sets up a server socket to wait for connections on a specific board we can accept the connections from clients uh read their inputs and send back responses Okay so
(16:59) yeah this methods requires more work on handling the details of network communication by ourself uh but it's a direct way to build server with just Java's standard features so yeah okay so how would you deploy a web application using a serate container like Apache tomat or JY without the spring okay so to deploy a web application using seret container like Apache topet or chti without spring first I think uh we need to First create a war file uh that contains a suet and other web resources okay then we have to
(17:38) configure our web application using a web.xml file to specify the serlet mappings and other settings okay then in the end we need we have to deploy the war file to The seret Container okay and uh to the Ser container by placing it in the appropriate directory or using using a containers management interface okay so the S container will automatically handle the deployment and uh making our uh web application access accessible via web browser okay so uh can you provide a example where Auto configuration simplifies
(18:18) development okay so yeah Auto configuration makes setting up projects much easier for example uh in a spring boot application uh just by adding spring boot starter web uh basically spring boot automatically sets up a tomet server okay for us and It prepares a basic for building applications and uh deals with common errors okay so uh normally uh doing all these uh would require manually configure each component which can be timec consuming and uh prone to mistakes okay but uh with auto configuration uh we can skip
(18:55) most of the setup work and start working on what our application needs to do it right away oh yeah this was the example of how okay yeah okay okay so uh can you discuss a scenario where you have to override the default Auto configuration provided by springboard scenario okay so actually yeah I haven't override over written yet so I'm not sure on the scenario side okay no problem so but do you know how can we achieve it uh yes I know so basically Auto configuration and spring boot works by automatically setting up our project
(19:39) based on the libraries we add okay for example if we includeed database Library spring boot configures a connection for us and this is done using by using spatial annotation in our for and that tells spring boot to scan for libraries and set things up accordingly so we can customize these settings for configuration files or code and this way uh much of initial setup work is done for us and it will be letting us focus on building our application so that's how can achieve okay so uh imagine you notice that a springboard application you are
(20:14) working on is significantly slower in production than in development environment okay so how would you go about fixing the problem okay so slower in production but first in development okay so when a spring boot application is slower in production than in development so I uh can start by checking the logs for errors or uh slow processes like why it is slow right then definitely I would use monitoring tools to track the performance metrics like uh memory usage CPU load and response times etc etc okay and then I would compare
(20:54) configuration between development and production to find the differences and uh also I will check if the database queries are optimized and if external Services used in the production are affecting performance so yeah based on these findings I'll make uh my final decision and definitely uh these things will improve my application in production okay so uh now imagine that you need to migrate a existing application to use a new database schia in springboard without downtime okay okay so uh how would you plan and
(21:27) execute this me okay so in order to migrate an application to a new database schema in Spring boot application without time time first uh I would create a new schema that works with the old and new versions right then I would update the application to support both the schemas and slowly uh and gradually I'll be shifting from old to new okay so uh by using datab I I'll use database migration tools as well like Flyway or liquid base for control changes and then finally I would test in a string environment and then deploy the update
(22:08) with the new schema in production and I'll and parall I will ensure the continuous operation throughout the process okay so uh have you hear about circular dependency uh yes so basically circular dependencies occur when two or more components depend on each other directly or indirectly uh and we'll be create and we will be creating a cycle so this situation can lead to problems like uh infinite Loops where each component waits for the other components to complete or issues with initialization as there's no clear starting point for
(22:44) any of the components right and it's a common issue in software development that requires carefully designed to avoid or isolve so yeah so uh okay how would you address the issue of circular dependency [Music] okay so actually I know about circular dependencies and I told you uh but uh addressing the issues actually I haven't addressed an issue yet so I'm not sure on this okay okay no problem so uh moving to the next question discuss the specific security challenges associated with using websocket uh in a springboard
(23:27) application okay so websockets in a spring boot application faces security issues because uh they keep a constant Connection open between the user and the server unlike the regular web pages okay and this can lead to the risk like attackers hijacking these connections to intercept or send fake messages right also without the usual Security checks uh we have for web pages uh and it's trickier to stop an authorize exit right and U to keep things safe uh it's also important to make sure only the right people can connect and uh to encrypt the
(24:00) data being sent uh back and forth so yeah that's all about BB so
