(341) EPAM 3 Years Interview Experience | Java Spring Boot - YouTube
https://www.youtube.com/watch?v=sOBKtUEEFp8

Transcript:
(00:00) hi uh sorry for being late uh shall we start now yeah yeah sure okay so uh could you tell me about yourself and your experience in Java development uh yeah sure so basically for the past three years uh I have been a Java developer and working on backend system by using spring board Spring Security rest API etc etc and after getting my computer science degree I started working on springboard microservices and connecting apis and then later I worked with complex projects and I also LED and delivered few features of the complex projects to
(00:37) the clients so that's all about myself and uh my experience in ja development okay so uh can you tell me about the projects where you applied these Frameworks uh okay so basically one of the most challenging project I worked on uh converting an existing monolithic application into microservice architecture for for a Financial Service Company right and uh the goal was to improve scalability and make the system more resilient to the changes and for this we basically chose spring boot for its microservices support and hibernate
(01:14) for omm features okay and the biggest challenge we faced was the data migration and dividing the monolithic database into the smaller and service specific right this was very difficult and we faced a lot of complexities in maintaining data consistency and handling transaction across services and to overcome this uh actually we implemented The Saga pattern for managing uh distributed transaction so yeah so that's how we applied these framework okay so uh what is this Saga pattern okay so uh basically The Saga
(01:54) pattern is a way to manage data consistency across microservices in a distributed transaction scenario imagine uh we are working with several different services and we need to make sure that some task are done correctly together okay so if something goes wrong and with one task and we have to go back and undo the previous task to avoid mess so it's kind of safety net and it will ensure that either everything complete successfully or if nothing happened at all through roll back okay so uh which Java version do
(02:30) you use uh in your current project uh currently we use Java 11 in our project so yeah okay okay so uh can you tell me uh some new features of java 11 which are not there in Aller version okay so uh basically Java 11 introduced several features like uh uh now we have new HTTP client API uh which officially made it easier for us to send HTTP request and HTTP responses right and this API support both synchronous and synchronous programming models and making our code flexible and Java 11 also introduced local variable Syntax
(03:12) for Lambda parameters basically it is enhancing the readability of lamb Expressions so this means now we can use a v keyword in Lambda expressions and making our food cleaner and more concise and along with these features Java 11 also introduced some string Methods like is blank strip strip leading etc etc so yeah okay so uh now moving to the next question uh can you tell me about singl t classes okay uh uh okay so basically a Singleton class in Java is a kind of a special class that can have only one stance or we can say one object at any
(03:54) time okay so it's like having only one key of the room and uh This Is Us useful when we want to make sure there's just one shared resource like a configuration setting or a connection to a database so yeah that Singleton classes okay okay so how can we create this Singleton classes okay so in order to make Singleton class uh first we have to make a Constructor as private right next we have to create a private static instance of the class right and uh finally uh we have to provide static method instance
(04:31) so yeah that's how we can create Singleton class okay so uh are these threads safe are these threads safe okay no actually single T classes are not thread save by default uh if multiple threads try to create an instance at the same time it could result in multiple instances okay so to prevent this we can synchronize the method that creates sensense or we also can use a static initializer okay so uh then how will you create a thread save single ton in Java using double check locking okay using double check locking okay so to create a thread shift
(05:19) single T in Java by using double check locking I would first declare a private static instance of the class uh but I won't initialize it right away okay and then I would make a public static method to get the instance inside this method I will check if the instance is null okay and uh if it is null I'll basically synchronize on a block using the class object and inside the synchronized block I will check again if the instant instance is null okay uh if it is still null then I will definitely initialize
(05:53) it and this way I'll only synchronize the first time the instance is created and making it a thread sh so yeah that how we can create a threat so uh now moving to the next question why the main method is public and static okay so main method is public because uh JRE Java runtime environment can exisit from outside the class as the main method is entry point of the program if it were not public then G would not be able to call it and it it will be preventing the program from starting so now talking about why it is
(06:35) a static because now it can be invoked without creating an instance or without creating an object of the class so when the program starts uh there is not any object of the class available to the uh main method okay and hence this method must be static and this allow J to call the main method directly using the class name without creating any instance of object okay so uh can we override this Min method uh I think uh yes we can technically overwrite this main method and actually uh here overwriting means changing the behavior of a method in a
(07:17) subass okay since the main method is static we can actually do is uh we can write a main method in a subass so it's not overriding but hiding the original main method and uh uh static method basically belong to the class they are defined in and not to the object of the class so when we Define a main method in a subass basically uh we are doing nothing but providing another entry point for the Java program and J can invoke any main method as a entry point when we run the application and it is Al it also depends on which class name we
(07:54) specified to the Java command so here it means we can have multiple main methods ACR different classes in our Java program which where each uh entry point Sorry where each this main method uh means as entry point and yeah so that's how you can over right okay so uh do you know about serialized data okay so yes serialized data uh means to the process of converting an object State into a format that can be easily stored or transmitted and then reconstru reconstructing it back into a copy of the original object so that is
(08:38) serialized data okay so uh and why shouldn't we serialize data into a text file okay so basically so because serialized data is a binary uh in serialized data in binary format and text files are made for text okay so when binary data is stored in a text file uh it means uh uh encoding issues can correct the data and making it unreadable or causing loss of information so it's more practical to use file formats like bin for binary serialized data okay and for human readable formats like converting objects
(09:17) to Json or XML then saving them in a text file I think it's a better approach so so yeah that's how I mean that's why we shouldn't serialize it okay so uh what happen if your serializable class contain a member that is not serializable and how will you fix it okay so basically if my seriable class contains a member uh that is not serializable then uh Java throws an error I think that is uh not serializable exception so when we try to serialize the object okay so this happens because the Java uh
(09:58) serialization mechanism requires all the objects member to support serialization if the object itself is to be serialized and uh uh in order to fix this issue I think I can make the member as serializable and I can mark the member as transient and I can make custom serialization so yeah by doing this uh we can fix this issue okay so uh what is this transient okay so basically transient is uh one of the keyword uh I think one of the keyword in Java and I'm not too much aware on this but I think it is used to
(10:37) indicate that a field should not be serialized okay when an object is serialized field Mark with transient as scripped and not included in the serialized representation of the object so I think this is useful for fields that are either not serializable themselves or that contains information that should not be persisted or uh or the uh I information is sensitive like password so I think that Isen okay nice so uh let's move to the next question uh how does garbage collection work in Java okay so basically garbage
(11:16) collection in Java automatically frees memory uh by removing object dat are no longer used okay and it finds objects that the program no longer references and basically it frees the memory use by these objects making space for new objects and this process helps prevent memory leaks and Java handle this automatically so to so we don't need to manually manage memory allocation and deallocation like how we used to do I think in other programming language like C okay so uh do finalized keyword has any role here in garbage
(11:54) collection uh yes uh the finalize uh I mean we have actually a method uh called name finalize that plays a role in a garbage collection in Java but it's limited and not recommended for General use so this method is actually called by garbage collector on an object when it's determined that there are no more references to the object and it means to give the object a chance to clean up resources before it's collected uh such as closing file streams or releasing uh network connection so yeah so uh can you tell me
(12:30) uh what algorithm jvm use for garbage collection okay me ah actually yeah I'm not aware on this okay okay okay no problem so uh how can we uh memory leaks occur in Java even we have automatic garbage collection okay so even with automatic garbage collection in Java memory leaks can occur if objects are unintentionally held in memory when they are no longer needed okay so this usually happens due to some reasons uh like first reason would be if an object is referenced by a static field it stays in a memory for
(13:13) the lifetime of the program because static Fields belong to the class not an object or instance second reion reason might be object stored in collection like list map sets Etc and not removed when they are no longer needed and can lead to memory leaks and third reason I think uh not registering callbacks can keep objects alive unnecessarily since the objects holding these references cannot be garbage collected so I think okay due to these reasons yeah okay okay so uh can you tell me uh the difference between Young Generation and old
(13:52) generation memory spaces okay so young generation and old generation sorry I'm not aware on this okay okay okay no problem so uh okay let's move to the different question uh how do you ensure the quality and maint maintainability of your code in your project okay so to ensure my project code quality and maintainability I actually focus on several practices okay I basically do regular code reviews with peers and definitely that can help catch bugs early and I also write unit test cases for individual components to
(14:36) confirm whether what I have done is uh working as expected or not and integration test to ensure the all the components are working together and I sometimes automate building and testing my code after each update that will uh quickly identify uh issues and I also tried to coverage I mean in code coverage up to 100% so these are my code practices and that's how that's how I ensure the quality and maintainability okay okay let's say uh You observe that a springboard application performs slower in the
(15:16) production environment compared to the development setup what step would you take to address this issue okay so when a spring boot application is slower in production than in a development so so I think I can start by checking the logs for errors or slow processes like why it is slow right then I would use monitoring tools to track the performance metrics like uh primary usage CPU load and response type and I think uh then I would compare configurations between development and production to find the differences and
(15:50) also I will check the database queries are optimized and if external Services used in production are affecting performance So based in based on these findings I'll make the decision and improve the application okay so uh can you tell me how do you integrate a relational database just like a MySQL uh with a springboard application okay so basically in order to integrate uh relational database like MySQL with is springboard application first uh we have to I mean uh first I add my SP dependency in projects building file like bom then in
(16:31) application properties file I set up the connection details for myql like database URL and credentials then I create a repository interfaces in our code using uh spring boot St data GPA which helps in interacting with mySQL and finally I use these repository in in my services to save uh update retrieve I mean all the cred operations in through this my SCH database okay so uh how would you modify uh an existing springboard application to convert into a server serverless architecture okay so uh I would break down the monolithic application uh first
(17:15) I would break down the monolithic application into the smaller and uh self-contained services and containerize them using Technologies like toker next I would select a serverless platform such as AWS Lambda or S functions and I would refactor the code of each services to work as independent serverless functions removing a necessary dependencies right then I would configure even triggers for these functions uh like I'll Define or time environment parameters and deploy them to the choosen serverless platform and
(17:51) and additionally I would set up an API Gateway if needed right and I would handle the data storage with serverless database and I'll ensure proper testing monitoring security practices and optimizing of course etc etc and so this transformation basically will enable better scalability and it will be it will reduce infrastructure management and cost efficiency and that's how uh uh I would modify an existing spring boot application into the serverless architecture okay so uh can you just tell me how does a spring board make the
(18:27) decision on which ser to use okay so yeah I can tell you so basically springbot decides which server to use based on the class part dependencies okay uh if a specific server dependency like Tomcat Jetty or under to is present then spring boot or to configure it as a default server uh right uh if no server dependency is found then spring boot defaults to Tom c as it's included the spring boot starter web right and I think this automatic ser selection uh sorry this automatically select simplify Set uh I mean this
(19:04) simplify our setup and configuration and it will allow us to focus more on developing the application rather than configuring server details okay so uh how would you handle a exceptions in a springboard rest application okay so basically to handle exceptions effectively in a spring boot rest application I would start by identifying the types of exception that might occur uh for example custom exception or built-in one like null pointer exception right and then next I would definitely create a custom exception class for specific error
(19:42) scenarios right and I would utilize controller advice annotation to create a dedicated class responsible for This Global exception headling okay and inside this class I would Define methods with the exceptional Handler with the exceptional Handler annot and each handling a specific exception type okay so these methods should return meaningful responses with appropriate HTTP status code and error message let's say if someone is returning I mean some code is returning 401 some might 404 so this way we are we'll be returning theor
(20:17) messages with the HTTP status code and when an exception occurs in my rest controller I would simply throw the corresponding custom exceptions and allowing spring boot to reroute it to the appropriate exceptional handling method so that's how I would handle exception in Spring boot rest application okay nice uh how can we handle multiple beans of the same type okay so yeah basically to handle multiple beans of the same type uh uh uh uh in a spring uh we can use qualifier annotation uh this lets us specify which
(20:58) Bean to inject and when there are multiple uh beans available okay for example if there are two beans of the type data source so we can give each name each a name and use qualifier annotation to tell spring which one to use okay and another way is to use primary annotation on one of the beans and it will be marking it as a default Choice when injecting the type okay so uh can you just tell me that in the spring framework uh what is the aspect oriented programming okay so basically aspect oriented programming is one of the
(21:37) programming approach that helps in separating concerns in our program uh especially those set cut across multiple parts of an application right and our main program uh code focuses on the core functionality while the aspects take care of the other common task that need to happen in various places like loging Security checks or managing transactions etc etc and for example uh in a Java application we might have methods where we want to log information every time they are called right or check that user has a right permission right let's say
(22:11) we have are having these methods uh right instead of putting this loging or security code into the every method you can Define it once in aspect and then specify where and when this code should be applied across our application this keepes our main code cleaner and more focus on its primary task so yeah that's all about expect oriented programming in the spring framework
